<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZeroMate: zero_mate::utils::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ZeroMate
   &#160;<span id="projectnumber">v1.4.1</span>
   </div>
   <div id="projectbrief">Raspberry Pi Zero Emulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacezero__mate_1_1utils_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">zero_mate::utils::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure to hold the result of the LSL, LSR, ASR, and ROR operations (functions).  <a href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa02e956362a59bab4b550bb0397943c3"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:aa02e956362a59bab4b550bb0397943c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#aa02e956362a59bab4b550bb0397943c3">Set_Bit</a> (Type &amp;value, Type idx, bool set) noexcept</td></tr>
<tr class="memdesc:aa02e956362a59bab4b550bb0397943c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a bit in the given integral variable.  <a href="namespacezero__mate_1_1utils_1_1math.html#aa02e956362a59bab4b550bb0397943c3">More...</a><br /></td></tr>
<tr class="separator:aa02e956362a59bab4b550bb0397943c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d93c996dab2ff1b91c5a399dcfe29f"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:af7d93c996dab2ff1b91c5a399dcfe29f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#af7d93c996dab2ff1b91c5a399dcfe29f">Is_Bit_Set</a> (Type value, Type idx) noexcept</td></tr>
<tr class="memdesc:af7d93c996dab2ff1b91c5a399dcfe29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a bit is set in the given integral variable.  <a href="namespacezero__mate_1_1utils_1_1math.html#af7d93c996dab2ff1b91c5a399dcfe29f">More...</a><br /></td></tr>
<tr class="separator:af7d93c996dab2ff1b91c5a399dcfe29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64baae537d736f483631d0256c6c44c1"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:a64baae537d736f483631d0256c6c44c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a64baae537d736f483631d0256c6c44c1">Is_Negative</a> (Type value) noexcept</td></tr>
<tr class="memdesc:a64baae537d736f483631d0256c6c44c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given integral value is negative by examining the MSB.  <a href="namespacezero__mate_1_1utils_1_1math.html#a64baae537d736f483631d0256c6c44c1">More...</a><br /></td></tr>
<tr class="separator:a64baae537d736f483631d0256c6c44c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb6c041e10bf6bed3c9e1ad4e9c568"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type, std::unsigned_integral Type_Narrower&gt; </td></tr>
<tr class="memitem:acccb6c041e10bf6bed3c9e1ad4e9c568"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#acccb6c041e10bf6bed3c9e1ad4e9c568">Is_Negative</a> (Type value) noexcept</td></tr>
<tr class="memdesc:acccb6c041e10bf6bed3c9e1ad4e9c568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the value is negative or not.  <a href="namespacezero__mate_1_1utils_1_1math.html#acccb6c041e10bf6bed3c9e1ad4e9c568">More...</a><br /></td></tr>
<tr class="separator:acccb6c041e10bf6bed3c9e1ad4e9c568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f8c7cc50ace3f59c22f49229adb1c"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:a218f8c7cc50ace3f59c22f49229adb1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a218f8c7cc50ace3f59c22f49229adb1c">LSL</a> (Type value, Type shift_size, bool carry_flag) noexcept</td></tr>
<tr class="memdesc:a218f8c7cc50ace3f59c22f49229adb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an LSL (logical shift left) operation on the given integral value.  <a href="namespacezero__mate_1_1utils_1_1math.html#a218f8c7cc50ace3f59c22f49229adb1c">More...</a><br /></td></tr>
<tr class="separator:a218f8c7cc50ace3f59c22f49229adb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a91ef10737eb5f77bd911e5fd2f3a20"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:a5a91ef10737eb5f77bd911e5fd2f3a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a5a91ef10737eb5f77bd911e5fd2f3a20">LSR</a> (Type value, Type shift_size) noexcept</td></tr>
<tr class="memdesc:a5a91ef10737eb5f77bd911e5fd2f3a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an LSR (logical shift right) operation on the given integral value.  <a href="namespacezero__mate_1_1utils_1_1math.html#a5a91ef10737eb5f77bd911e5fd2f3a20">More...</a><br /></td></tr>
<tr class="separator:a5a91ef10737eb5f77bd911e5fd2f3a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68141550583056ded49ff399b4315992"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:a68141550583056ded49ff399b4315992"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a68141550583056ded49ff399b4315992">ASR</a> (Type value, Type shift_size) noexcept</td></tr>
<tr class="memdesc:a68141550583056ded49ff399b4315992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an ASR (arithmetic shift right) operation on the given integral value.  <a href="namespacezero__mate_1_1utils_1_1math.html#a68141550583056ded49ff399b4315992">More...</a><br /></td></tr>
<tr class="separator:a68141550583056ded49ff399b4315992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdc39df63ef0d6d33123bac4fffb89b"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:a9cdc39df63ef0d6d33123bac4fffb89b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a9cdc39df63ef0d6d33123bac4fffb89b">ROR</a> (Type value, Type shift_size, bool carry_flag) noexcept</td></tr>
<tr class="memdesc:a9cdc39df63ef0d6d33123bac4fffb89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an ROR (rotate right extended) operation on the given integral value.  <a href="namespacezero__mate_1_1utils_1_1math.html#a9cdc39df63ef0d6d33123bac4fffb89b">More...</a><br /></td></tr>
<tr class="separator:a9cdc39df63ef0d6d33123bac4fffb89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047293b62420dfdc6808cb5e667fd0f"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Type&gt; </td></tr>
<tr class="memitem:aa047293b62420dfdc6808cb5e667fd0f"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#aa047293b62420dfdc6808cb5e667fd0f">ROR</a> (Type value, Type rot) noexcept</td></tr>
<tr class="memdesc:aa047293b62420dfdc6808cb5e667fd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a rotate right operation on the given integral value.  <a href="namespacezero__mate_1_1utils_1_1math.html#aa047293b62420dfdc6808cb5e667fd0f">More...</a><br /></td></tr>
<tr class="separator:aa047293b62420dfdc6808cb5e667fd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c75d7ad2f6b38c25ccf169c6a5e8649"><td class="memTemplParams" colspan="2">template&lt;std::signed_integral Type&gt; </td></tr>
<tr class="memitem:a1c75d7ad2f6b38c25ccf169c6a5e8649"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a1c75d7ad2f6b38c25ccf169c6a5e8649">Check_Overflow_Subtraction</a> (Type <a class="el" href="alu_8cpp.html#a80badebd2dc78607ff61f66476d1fc49">op1</a>, Type <a class="el" href="alu_8cpp.html#af3792125376f52ba7ccfc21dbdab6cc3">op2</a>) noexcept</td></tr>
<tr class="memdesc:a1c75d7ad2f6b38c25ccf169c6a5e8649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if performing op1 - op2 would either an overflow or underflow.  <a href="namespacezero__mate_1_1utils_1_1math.html#a1c75d7ad2f6b38c25ccf169c6a5e8649">More...</a><br /></td></tr>
<tr class="separator:a1c75d7ad2f6b38c25ccf169c6a5e8649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114bc966800c0a464e64cf912b12cea7"><td class="memTemplParams" colspan="2">template&lt;std::signed_integral Type&gt; </td></tr>
<tr class="memitem:a114bc966800c0a464e64cf912b12cea7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a114bc966800c0a464e64cf912b12cea7">Check_Overflow_Addition</a> (Type <a class="el" href="alu_8cpp.html#a80badebd2dc78607ff61f66476d1fc49">op1</a>, Type <a class="el" href="alu_8cpp.html#af3792125376f52ba7ccfc21dbdab6cc3">op2</a>) noexcept</td></tr>
<tr class="memdesc:a114bc966800c0a464e64cf912b12cea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if performing op1 + op2 would either an overflow or underflow.  <a href="namespacezero__mate_1_1utils_1_1math.html#a114bc966800c0a464e64cf912b12cea7">More...</a><br /></td></tr>
<tr class="separator:a114bc966800c0a464e64cf912b12cea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6982f28e8dee9d4673f319616fa1b756"><td class="memTemplParams" colspan="2">template&lt;std::signed_integral Type&gt; </td></tr>
<tr class="memitem:a6982f28e8dee9d4673f319616fa1b756"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a6982f28e8dee9d4673f319616fa1b756">Check_Overflow</a> (Type <a class="el" href="alu_8cpp.html#a80badebd2dc78607ff61f66476d1fc49">op1</a>, Type <a class="el" href="alu_8cpp.html#af3792125376f52ba7ccfc21dbdab6cc3">op2</a>, bool <a class="el" href="alu_8cpp.html#abfdc8b2e0f21af195c33a2221a87373c">subtraction</a>, Type carry) noexcept</td></tr>
<tr class="memdesc:a6982f28e8dee9d4673f319616fa1b756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if adding or subtracting the two operands (including the carry flag) causes an overflow/underflow.  <a href="namespacezero__mate_1_1utils_1_1math.html#a6982f28e8dee9d4673f319616fa1b756">More...</a><br /></td></tr>
<tr class="separator:a6982f28e8dee9d4673f319616fa1b756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda20fa50949a9cd3a80f811b0085221"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral Small_Type, std::unsigned_integral Large_Type = std::uint32_t&gt; </td></tr>
<tr class="memitem:afda20fa50949a9cd3a80f811b0085221"><td class="memTemplItemLeft" align="right" valign="top">Large_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html#afda20fa50949a9cd3a80f811b0085221">Sign_Extend_Value</a> (Small_Type value) noexcept</td></tr>
<tr class="memdesc:afda20fa50949a9cd3a80f811b0085221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends the given integral value.  <a href="namespacezero__mate_1_1utils_1_1math.html#afda20fa50949a9cd3a80f811b0085221">More...</a><br /></td></tr>
<tr class="separator:afda20fa50949a9cd3a80f811b0085221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a68141550583056ded49ff399b4315992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68141550583056ded49ff399b4315992">&#9670;&nbsp;</a></span>ASR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt;Type&gt; zero_mate::utils::math::ASR </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>shift_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an ASR (arithmetic shift right) operation on the given integral value. </p>
<p>The following tool can be used to see how these kinds of shifts/rotations work: <a href="https://onlinetoolz.net/bitshift">https://onlinetoolz.net/bitshift</a>. Their implementation is also explained in the ARM instruction set manual: <a href="https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf">https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf</a> (section 4.5.2 - Shifts)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value used in the operation </td></tr>
    <tr><td class="paramname">shift_size</td><td>Number of positions the value will be shifted by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html" title="Helper structure to hold the result of the LSL, LSR, ASR, and ROR operations (functions).">TShift_Result</a>, result of the shift operation </dd></dl>

</div>
</div>
<a id="a6982f28e8dee9d4673f319616fa1b756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6982f28e8dee9d4673f319616fa1b756">&#9670;&nbsp;</a></span>Check_Overflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::signed_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zero_mate::utils::math::Check_Overflow </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subtraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>carry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if adding or subtracting the two operands (including the carry flag) causes an overflow/underflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the two operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operand </td></tr>
    <tr><td class="paramname">op2</td><td>Second operand </td></tr>
    <tr><td class="paramname">subtraction</td><td>Flag indicating whether the operands should be subtracted or added up </td></tr>
    <tr><td class="paramname">carry</td><td>Carry flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the operation causes an overflow/underflow. false, otherwise. </dd></dl>

</div>
</div>
<a id="a114bc966800c0a464e64cf912b12cea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114bc966800c0a464e64cf912b12cea7">&#9670;&nbsp;</a></span>Check_Overflow_Addition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::signed_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zero_mate::utils::math::Check_Overflow_Addition </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if performing op1 + op2 would either an overflow or underflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the two operands the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operand </td></tr>
    <tr><td class="paramname">op2</td><td>Second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if adding up the two operands causes an overflow or underflow. false, if it is safe to perform the operation. </dd></dl>

</div>
</div>
<a id="a1c75d7ad2f6b38c25ccf169c6a5e8649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c75d7ad2f6b38c25ccf169c6a5e8649">&#9670;&nbsp;</a></span>Check_Overflow_Subtraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::signed_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zero_mate::utils::math::Check_Overflow_Subtraction </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if performing op1 - op2 would either an overflow or underflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the two operands the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operand </td></tr>
    <tr><td class="paramname">op2</td><td>Second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if subtracting the two operands causes an overflow or underflow. false, if it is safe to perform the operation. </dd></dl>

</div>
</div>
<a id="af7d93c996dab2ff1b91c5a399dcfe29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d93c996dab2ff1b91c5a399dcfe29f">&#9670;&nbsp;</a></span>Is_Bit_Set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zero_mate::utils::math::Is_Bit_Set </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a bit is set in the given integral variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value whose bit is going to be tested </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the bit to be tested for a 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the bit is set to a 1. false, otherwise </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacezero__mate_1_1utils_1_1math_af7d93c996dab2ff1b91c5a399dcfe29f_icgraph.svg" width="662" height="519"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a64baae537d736f483631d0256c6c44c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64baae537d736f483631d0256c6c44c1">&#9670;&nbsp;</a></span>Is_Negative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zero_mate::utils::math::Is_Negative </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the given integral value is negative by examining the MSB. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to be check for being negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the MSB is set (the value is negative). false, otherwise. </dd></dl>

</div>
</div>
<a id="acccb6c041e10bf6bed3c9e1ad4e9c568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccb6c041e10bf6bed3c9e1ad4e9c568">&#9670;&nbsp;</a></span>Is_Negative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type, std::unsigned_integral Type_Narrower&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zero_mate::utils::math::Is_Negative </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the value is negative or not. </p>
<p>The position of the MSB is determined by Type_Narrower. For example, if <a class="el" href="namespacezero__mate_1_1utils_1_1math.html#a64baae537d736f483631d0256c6c44c1" title="Checks whether the given integral value is negative by examining the MSB.">Is_Negative&lt;std::uint32_t, std::uint8_t&gt;</a> is called, the 7th bit (starting from 0) of the value is treated as the most significant bit (MSB).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
    <tr><td class="paramname">Type_Narrower</td><td>This determines the MSB position in the value that is supposed to be of a larger datatype </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to be check for being negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the value is negative. false, otherwise. </dd></dl>

</div>
</div>
<a id="a218f8c7cc50ace3f59c22f49229adb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f8c7cc50ace3f59c22f49229adb1c">&#9670;&nbsp;</a></span>LSL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt;Type&gt; zero_mate::utils::math::LSL </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>shift_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>carry_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an LSL (logical shift left) operation on the given integral value. </p>
<p>The following tool can be used to see how these kinds of shifts/rotations work: <a href="https://onlinetoolz.net/bitshift">https://onlinetoolz.net/bitshift</a>. Their implementation is also explained in the ARM instruction set manual: <a href="https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf">https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf</a> (section 4.5.2 - Shifts)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value used in the operation </td></tr>
    <tr><td class="paramname">shift_size</td><td>Number of positions the value will be shifted by </td></tr>
    <tr><td class="paramname">carry_flag</td><td>Carry flag from the CPSR register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html" title="Helper structure to hold the result of the LSL, LSR, ASR, and ROR operations (functions).">TShift_Result</a>, result of the shift operation </dd></dl>

</div>
</div>
<a id="a5a91ef10737eb5f77bd911e5fd2f3a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a91ef10737eb5f77bd911e5fd2f3a20">&#9670;&nbsp;</a></span>LSR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt;Type&gt; zero_mate::utils::math::LSR </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>shift_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an LSR (logical shift right) operation on the given integral value. </p>
<p>The following tool can be used to see how these kinds of shifts/rotations work: <a href="https://onlinetoolz.net/bitshift">https://onlinetoolz.net/bitshift</a>. Their implementation is also explained in the ARM instruction set manual: <a href="https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf">https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf</a> (section 4.5.2 - Shifts)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value used in the operation </td></tr>
    <tr><td class="paramname">shift_size</td><td>Number of positions the value will be shifted by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html" title="Helper structure to hold the result of the LSL, LSR, ASR, and ROR operations (functions).">TShift_Result</a>, result of the shift operation </dd></dl>

</div>
</div>
<a id="aa047293b62420dfdc6808cb5e667fd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa047293b62420dfdc6808cb5e667fd0f">&#9670;&nbsp;</a></span>ROR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type zero_mate::utils::math::ROR </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a rotate right operation on the given integral value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to be rotated </td></tr>
    <tr><td class="paramname">rot</td><td>Number of positions the value will be rotated by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the rotation </dd></dl>

</div>
</div>
<a id="a9cdc39df63ef0d6d33123bac4fffb89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdc39df63ef0d6d33123bac4fffb89b">&#9670;&nbsp;</a></span>ROR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html">TShift_Result</a>&lt;Type&gt; zero_mate::utils::math::ROR </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>shift_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>carry_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an ROR (rotate right extended) operation on the given integral value. </p>
<p>The following tool can be used to see how these kinds of shifts/rotations work: <a href="https://onlinetoolz.net/bitshift">https://onlinetoolz.net/bitshift</a>. Their implementation is also explained in the ARM instruction set manual: <a href="https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf">https://iitd-plos.github.io/col718/ref/arm-instructionset.pdf</a> (section 4.5.2 - Shifts)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value used in the operation </td></tr>
    <tr><td class="paramname">shift_size</td><td>Number of positions the value will be rotated by </td></tr>
    <tr><td class="paramname">carry_flag</td><td>Carry flag from the CPSR register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structzero__mate_1_1utils_1_1math_1_1TShift__Result.html" title="Helper structure to hold the result of the LSL, LSR, ASR, and ROR operations (functions).">TShift_Result</a>, result of the shift operation </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacezero__mate_1_1utils_1_1math_a9cdc39df63ef0d6d33123bac4fffb89b_icgraph.svg" width="951" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa02e956362a59bab4b550bb0397943c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02e956362a59bab4b550bb0397943c3">&#9670;&nbsp;</a></span>Set_Bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zero_mate::utils::math::Set_Bit </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a bit in the given integral variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the variable the function is called with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value whose bit is going to be set </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the bit to be set </td></tr>
    <tr><td class="paramname">set</td><td>Indication of whether the bit should be set to a 1 or 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afda20fa50949a9cd3a80f811b0085221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda20fa50949a9cd3a80f811b0085221">&#9670;&nbsp;</a></span>Sign_Extend_Value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral Small_Type, std::unsigned_integral Large_Type = std::uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Large_Type zero_mate::utils::math::Sign_Extend_Value </td>
          <td>(</td>
          <td class="paramtype">Small_Type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends the given integral value. </p>
<p>If the value is positive, it is simple extended to the large datatype. If the is negative, the final result is made up of all 0xF, except for the least significant bits which hold the representation of the given value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Small_Type</td><td>Type of the value passed in as a parameter </td></tr>
    <tr><td class="paramname">Large_Type</td><td>Type to which the value will be sign-extended </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to be sign-extended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sign-extended value </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacezero__mate_1_1utils_1_1math_afda20fa50949a9cd3a80f811b0085221_icgraph.svg" width="676" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacezero__mate.html">zero_mate</a></li><li class="navelem"><a class="el" href="namespacezero__mate_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="namespacezero__mate_1_1utils_1_1math.html">math</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
